/*!

Binding for the iconv library

[![Build Status](https://drone.io/github.com/andelf/rust-iconv/status.png)](https://drone.io/github.com/andelf/rust-iconv/latest)

 */

#![crate_name = "iconv"]
#![crate_type = "lib"]
#![doc(html_logo_url = "http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png",
       html_favicon_url = "http://www.rust-lang.org/favicon.ico",
       html_root_url = "http://static.rust-lang.org/doc/master")]

use std::mem;
use std::vec::Vec;
use std::io;
use std::io::{Read, Write};
use libc::{E2BIG, EILSEQ, EINVAL};
use std::ptr;
use std::str;
use std::ffi::CString;
use std::iter;

const DEFAULT_BUF_SIZE: usize = 64 * 1024;

/* automatically generated by rust-bindgen */
/* and then manually modified :P */

use libc::{c_char, size_t, c_int, c_void};
#[allow(non_camel_case_types)]
type iconv_t = *mut c_void;

#[cfg(target_os = "macos")]
#[link(name = "iconv")]
extern {}

// iconv is part of linux glibc
#[cfg(target_os = "linux")]
extern {}

extern "C" {
    fn iconv_open(__tocode: *const c_char, __fromcode: *const c_char) -> iconv_t;
    fn iconv(__cd: iconv_t, __inbuf: *mut *mut c_char,
                 __inbytesleft: *mut size_t, __outbuf: *mut *mut c_char,
                 __outbytesleft: *mut size_t) -> size_t;
    fn iconv_close(__cd: iconv_t) -> c_int;
}
/* automatically generated ends */

/// The representation of a iconv converter
pub struct Converter {
    cd: iconv_t,
}

impl Converter {
    /// Creates a new Converter from ``from`` encoding and ``to`` encoding.
    pub fn new(from: &str, to: &str) -> Converter {
        let from_encoding = CString::new(from).unwrap();
        let to_encoding = CString::new(to).unwrap();

        let handle = unsafe {
            iconv_open(to_encoding.as_ptr(), from_encoding.as_ptr())
        };
        if handle as isize == -1 {
            panic!("Error creating conversion descriptor from {:} to {:}", from, to);
        }
        Converter { cd: handle }
    }

    /// Convert from input into output.
    /// Returns (bytes_read, bytes_written, errno).
    pub fn convert(&self, input: &[u8], output: &mut [u8]) -> (usize, usize, c_int) {
        let input_left = input.len() as size_t;
        let output_left = output.len() as size_t;

        if input_left > 0 && output_left > 0 {
            let input_ptr = input.as_ptr();
            let output_ptr = output.as_ptr();

            let ret = unsafe { iconv(self.cd,
                                     mem::transmute(&input_ptr), mem::transmute(&input_left),
                                     mem::transmute(&output_ptr), mem::transmute(&output_left))
            };
            let bytes_read = input.len() - input_left as usize;
            let bytes_written = output.len() - output_left as usize;

            return (bytes_read, bytes_written, if ret as isize == -1 { io::Error::last_os_error().raw_os_error().unwrap() as c_int } else { 0 })
        } else if input_left == 0 && output_left > 0 {
            let output_ptr = output.as_ptr();

            let ret = unsafe { iconv(self.cd,
                                     ptr::null_mut::<*mut c_char>(), mem::transmute(&input_left),
                                     mem::transmute(&output_ptr), mem::transmute(&output_left))
            };

            let bytes_written = output.len() - output_left as usize;

            return (0, bytes_written, if ret as isize == -1 { io::Error::last_os_error().raw_os_error().unwrap() as c_int } else { 0 })
        } else {
            let ret = unsafe { iconv(self.cd,
                                     ptr::null_mut::<*mut c_char>(), mem::transmute(&input_left),
                                     ptr::null_mut::<*mut c_char>(), mem::transmute(&output_left))
            };

            return (0, 0, if ret as isize == -1 { io::Error::last_os_error().raw_os_error().unwrap() as c_int } else { 0 })
        }
    }
}

impl Drop for Converter {
    fn drop(&mut self) {
        unsafe { iconv_close(self.cd) };
    }
}

/// A ``Reader`` which does iconv convert from another Reader.
pub struct IconvReader<R> {
    inner: R,
    conv: Converter,
    buf: Vec<u8>,
    read_pos: usize,
    write_pos: usize,
    tempbuf: Vec<u8> // used when outbut is too small and can't make a single convertion
}

impl<R: io::Read> IconvReader<R> {
    pub fn new(r: R, from: &str, to: &str) -> IconvReader<R> {
        IconvReader::with_capacity(r, from, to, DEFAULT_BUF_SIZE)
    }

    pub fn with_capacity(r: R, from: &str, to: &str, capacity: usize) -> IconvReader<R> {
        let conv = Converter::new(from, to);
        let buf = vec![0; capacity];
        IconvReader { inner: r, conv: conv,
                      buf: buf,
                      read_pos: 0, write_pos: 0,
                      tempbuf: Vec::new(), // small buf allocate dynamicly
        }
    }

    fn fill_buf(&mut self) -> io::Result<usize> {
        if self.read_pos > 0 {
            self.buf.rotate_left(self.read_pos);
            self.write_pos -= self.read_pos;
            self.read_pos = 0;
        }
        match self.inner.read(&mut self.buf[self.write_pos..]) {
            Ok(nread) => {
                self.write_pos += nread;
                Ok(nread)
            }
            Err(e) => {
                Err(e)
            }
        }
    }
}

impl<R: Read> Read for IconvReader<R> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        if self.tempbuf.len() != 0 {
            let mut nwrite = 0;
            for slot in self.tempbuf.iter() {
                buf[nwrite] = *slot;
                nwrite += 1;
            }
            //let nwrite = buf.clone_from_slice(self.tempbuf.as_ref());
            if nwrite < self.tempbuf.len() {
                self.tempbuf = self.tempbuf[nwrite..].to_vec();
            } else {
                self.tempbuf = Vec::new();
            }
            return Ok(nwrite);
        }

        if self.write_pos == 0 || self.read_pos == self.write_pos {
            match self.fill_buf() {
                Err(e) =>  {
                    return Err(io::Error::new(e.kind(), ""));
                },
                Ok(read) => {
                    if read == 0 {
                        return Ok(0);
                    }
                }
            }
        }

        let (nread, nwrite, err) = self.conv.convert(
            &self.buf[self.read_pos..self.write_pos],
            buf);

        self.read_pos += nread;

        match err {
            EILSEQ => {
                Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "An invalid multibyte sequence has been encountered in the input."))
            },
            EINVAL => {
                match self.fill_buf() {
                    Err(e) => {
                        Err(io::Error::new(e.kind(), ""))
                    },
                    Ok(read) => {
                        if read == 0 {
                            Err(io::Error::new(
                                io::ErrorKind::InvalidInput,
                                "An incomplete multibyte sequence has been encountered in the input."))
                        } else {
                            match self.read(&mut buf[nwrite..]) {
                                Ok(nwrite_req) => {
                                    Ok(nwrite + nwrite_req)
                                },
                                Err(e) => {
                                    Err(io::Error::new(e.kind(), ""))
                                }
                            }
                        }
                    }
                }
            },
            E2BIG => {
                log::debug!("There is not sufficient room at *outbuf.");
                // FIXED: if outbuf buffer has size 1? Can't hold a
                if nread == 0 && nwrite == 0 && buf.len() > 0 {
                    // outbuf too small and can't conv 1 rune
                    let mut tempbuf = Vec::with_capacity(8);
                    tempbuf.extend(iter::repeat(0u8).take(8));
                    assert!(self.tempbuf.is_empty());
                    let (_nread, temp_nwrite, err) = self.conv.convert(
                        &self.buf[self.read_pos..self.write_pos],
                        &mut tempbuf[..]);

                    // here we will write 1 or 2 bytes as most.
                    // try avoiding return Ok(0)
                    let mut nwrite = 0;
                    for slot in tempbuf.iter() {
                        buf[nwrite] = *slot;
                        nwrite += 1
                    }
                    //buf.clone_from_slice(tempbuf.as_slice());
                    self.tempbuf = tempbuf[nwrite..temp_nwrite].to_vec();
                    match err {
                        EILSEQ => Err(io::Error::new(io::ErrorKind::InvalidInput, "")),
                        _ => Ok(nwrite)
                    }
                } else {
                    Ok(nwrite)
                }
            },
            0 => {
                Ok(nwrite)
            },
            _ => {
                Err(io::Error::new(io::ErrorKind::Other,
                                   format!("Unexpected error response: {}", err)))
            }
        }
    }
}

struct Buffer {
    buf: Vec<u8>,
    len: usize
}

impl Buffer {
    #[inline]
    fn readable(&self) -> &[u8] {
        &self.buf[..self.len]
    }

    #[inline]
    fn writable(&mut self) -> &mut [u8] {
        &mut self.buf[self.len..]
    }

    #[inline]
    fn written(&mut self, n: usize) {
        self.len += n;
    }

    /// Clear the buffer.
    #[inline]
    fn clear(&mut self) {
        self.len = 0;
    }
}

/// A ``Writer`` which does iconv convert into another Writer.
#[allow(dead_code)]
pub struct IconvWriter<W: io::Write> {
    wtr: Option<W>,
    conv: Converter,
    buf: Buffer,
    panicked: bool
}

impl<W: Write> IconvWriter<W> {
    pub fn new(w: W, from: &str, to: &str) -> IconvWriter<W> {
        IconvWriter::with_capacity(w, from, to, DEFAULT_BUF_SIZE)
    }
    pub fn with_capacity(w: W, from: &str, to: &str, capacity: usize) -> IconvWriter<W> {
        let conv = Converter::new(from, to);
        let buf = Buffer { buf: vec![0; capacity], len: 0 };
        IconvWriter { wtr: Some(w), conv, buf,
                      panicked: false,
        }
    }

    fn flush_buf(&mut self) -> io::Result<()> {
        self.panicked = true;
        let result = self.wtr.as_mut().unwrap().write_all(self.buf.readable());
        self.panicked = false;
        result?;
        self.buf.clear();
        Ok(())
    }
}

impl<W: Write> Write for IconvWriter<W> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        let (bytes_read, bytes_written, err) = self.conv.convert(
            buf,
            self.buf.writable());
        self.buf.written(bytes_written);

        match err {
            EILSEQ => {
                Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "An invalid multibyte sequence has been encountered in the input."))
            },
            EINVAL | 0 => {
                // EINVAL: incomplete multibyte sequence, just wait for new input
                Ok(bytes_read)
            },
            E2BIG => {
                // we can just flush the buffer, and try again next "write"
                self.flush_buf()?;
                Ok(bytes_read)
            },
            _ => {
                Err(io::Error::new(io::ErrorKind::Other,
                                   format!("Unexpected error response: {}", err)))
            }
        }
    }

    fn flush(&mut self) -> io::Result<()> {
        self.flush_buf()?;
        self.wtr.as_mut().unwrap().flush()?;
        Ok(())
    }
}

impl<W: Write> Drop for IconvWriter<W> {
    fn drop(&mut self) {
        if self.wtr.is_some() && !self.panicked {
            let _ = self.flush();
        }
    }
}

// TODO: use Result<> instead of Option<> to indicate Error
fn convert_bytes(inbuf: &[u8], from: &str, to: &str) -> Option<Vec<u8>> {
    let converter = Converter::new(from, to);
    let mut outbuf_size = inbuf.len() * 2;
    let mut total_nread = 0;
    let mut total_nwrite = 0;

    let mut outbuf = Vec::with_capacity(outbuf_size);
    unsafe { outbuf.set_len(outbuf_size) };

    while total_nread < inbuf.len() {
        let (nread, nwrite, err) = converter.convert(&inbuf[total_nread..],
                                                     &mut outbuf[total_nwrite..]);

        total_nread += nread;
        total_nwrite += nwrite;

        match err {
            EINVAL | EILSEQ => return None,
            E2BIG => {
                outbuf_size += inbuf.len();
                outbuf.reserve(outbuf_size);
                unsafe { outbuf.set_len(outbuf_size) };
            }
            _ => ()
        }
    }

    unsafe { outbuf.set_len(total_nwrite) };
    outbuf.shrink_to_fit();

    return Some(outbuf);
}


/// Can be encoded to bytes via iconv
pub trait IconvEncodable {
    /// Encode to bytes with encoding
    fn encode_with_encoding(&self, encoding: &str) -> Option<Vec<u8>>;
}

impl<'a> IconvEncodable for &'a [u8] {
    fn encode_with_encoding(&self, encoding: &str) -> Option<Vec<u8>> {
        convert_bytes(*self, "UTF-8", encoding)
    }
}

impl<'a> IconvEncodable for Vec<u8> {
    fn encode_with_encoding(&self, encoding: &str) -> Option<Vec<u8>> {
        convert_bytes(&self[..], "UTF-8", encoding)
    }
}

impl<'a> IconvEncodable for &'a str {
    fn encode_with_encoding(&self, encoding: &str) -> Option<Vec<u8>> {
        return self.as_bytes().encode_with_encoding(encoding);
    }
}

impl<'a> IconvEncodable for String {
    fn encode_with_encoding(&self, encoding: &str) -> Option<Vec<u8>> {
        return self.as_bytes().encode_with_encoding(encoding);
    }
}

/// Can be decoded to str via iconv
pub trait IconvDecodable {
    /// Decode to str with encoding
    fn decode_with_encoding(&self, encoding: &str) -> Option<String>;
}

impl<'a> IconvDecodable for &'a [u8] {
    fn decode_with_encoding(&self, encoding: &str) -> Option<String> {
        convert_bytes(*self, encoding, "UTF-8").and_then(|bs| {
            str::from_utf8(&bs[..]).map(|s| { s.to_string() }).ok()
        })
    }
}

impl<'a> IconvDecodable for Vec<u8> {
    fn decode_with_encoding(&self, encoding: &str) -> Option<String> {
        convert_bytes(&self[..], encoding, "UTF-8").and_then(|bs| {
            str::from_utf8(&bs[..]).map(|s| { s.to_string() }).ok()
        })
    }
}


#[cfg(test)]
mod test {
    use std::io;
    use std::io::{BufReader, BufWriter};
    use std::iter;
    use std::io::{Read, Write};

    use super::*;

    #[test]
    fn test_reader_simple() {
        let a = "噗哈";
        let r = BufReader::new(a.as_bytes());
        let mut cr = IconvReader::with_capacity(r, "UTF-8", "GBK", 100);

        let mut buf = [0u8; 8];
        let res = cr.read(&mut buf);
        assert!(res.is_ok());
        assert_eq!(res.unwrap(), 4);
        assert_eq!(buf, vec![0xe0, 0xdb, 0xb9, 0xfe, 0, 0, 0, 0][..]);
    }

    #[test]
    fn test_reader_small_buf() {
        let a = "噗哈";
        let r = BufReader::new(a.as_bytes());
        let mut cr = IconvReader::with_capacity(r, "UTF-8", "GBK", 100);

        let mut buf = [0u8; 3];
        let res = cr.read(&mut buf);
        assert!(res.is_ok());
        assert_eq!(res.unwrap(), 2);
        assert_eq!(buf, vec![0xe0, 0xdb, 0][..]);

        let mut buf = [0u8; 3];
        let res = cr.read(&mut buf);
        assert!(res.is_ok());
        assert_eq!(res.unwrap(), 2);
        assert_eq!(buf, vec![0xb9, 0xfe, 0][..]);
    }

    #[test]
    fn test_reader_large() {
        let a = "噗哈";
        let cont = iter::repeat(a).take(1024).collect::<Vec<&str>>().join("");

        let r = BufReader::new(cont.as_bytes());
        let mut cr = IconvReader::with_capacity(r, "UTF-8", "GBK", 100);

        let mut nread = 0;
        loop {
            let mut buf = [0u8; 4];
            let res = cr.read(&mut buf[..]);
            match res {
                Ok(n) => {
                    if n == 4 {
                        //println!("nread = {}", nread);
                        assert_eq!(buf, &vec!(224, 219, 185, 254)[..]);
                        nread += 4;
                    } else if n == 0 {
                        break;
                    } else {
                        println!("{}", n);
                        unreachable!();
                    }
                }
                Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {
                    return ;
                }
                _ => {
                    println!("fuck {:?} {:?}", res, buf);
                    unreachable!();
                }
            }
        }
        assert_eq!(nread, 1024 * 4);
    }

    const LOREM_IPSUM_JP_SHIFT_JIS_BYTES: [u8; 741] = *b"\x91\xb1\x82\xda\x82\xd0\x82\xaf\x82\xd4\x93\xfa3\x8d\xcf\x82\xc8\x82\xc4\x82\xd0\x97\xac\x8a\xfa\x82\xbf\x82\xc8\x8b\xd6\x95\x90\x83\x91\x83Z\x83w\x83l\x8e\xf123\x94\xcc\x94\xad\x83\x89\x83m\x83\x8f\x95\xf1\x8b\x9e\x82\xd4\x82\xb9\x8cv\x8b\xb3\x83\x92\x83j\x83\x86\x83T\x96\xda\x93\x8a39\x8d\xec\x83V\x83\x8f\x83j\x90\xbc8\x8ae\x94@\x82\xcb\x81B\x8e\xbf\x83\x8b\x83\x80\x83t\x83l\x91f\x94M\x82\xc6\x82\xeb\x82\xe2\x8c\xa0\x8e\xca\x83C\x83\x8b\x83T\x8f\xab\x90}\x8c|\x83`\x83X\x83q\x83Z\x97V\x8f\x9c\x82\xc8\x82\xea\x83C\x82\xd0\x93\xfa\x8c\xa9\x83\x8a\x83\x88\x90M\x8a\xfa\x96h\x96\xc5\x95[\x82\xad\x82\xa2\x89\x9f\x8a\xd6\x95\xc4\x83n\x95K\x94\\\x82\xdf\x83\x8c\x82\xce\x89\xef2\x8ae\x83\x93\x83t\x82\xa9\x94O\x89\xbb\x82\xd4\x82\xa9\x82\xdf\x82\xf1\x93\xfc\x95\xc4\x83`\x83\x89\x83\x8b\x83\x8a\x94\xf2\x89\x80\x95\xd4\x8e\xf7\x82\xda\x82\xcb\x82\xa6\x81B\x8c\x9b\x82\xed\x83t\x91\xd1\x90\xa3\x94\xf1\x82\xc7\x82\xd9\x82\xe7\x8d\xe0\x88\xc4\x82\xb4\x82\xb7\x82\xab\x8d\xe3\x97Y\x89\xef\x83e\x83N\x83}\x83\x86\x93\xfa\x8cv\x83T\x8d\xac\x8eq\x82\xe8\x82\xcf\x92\xb2\x92\xb2\x82\xac\x82\xd0\x82\xcd\x90l\x8e\xca\x82\xd0\x82\xda\x83\x93\x82\xab\x8ap\x8b\xc7\x83R\x8ew\x8e\xf9\x83\\\x83`\x83j\x89\x9e\x8eq\x83V\x83k\x83\x84\x8b\x9e\x8c\x8f\x82\xac\x82\xb6\x8e\xa1\x94\xad\x82\xe3\x8d\xe3\x97Z\x94V\x89\x9f\x82\xaa\x82\xe7\x82\xd3\x81B\n\n\x95\xe0\x82\xbb\x83\x93\x8eZ\x88\xe4\x82\xc9\x83\x8a\x82\xb1\x97\xcc\x89\x89\x82\xde\x82\xdd\x82\xb3\x8f\xe3\x89f\x82\xd6\x83h\x8b\xe09\x93\xdc\x8e\xba\x82\xe9\x8a\xe2\x90l\x83t\x92\xca\x8d\xda\x81[\x83\x8b\x82\xe2\x83X\x94\xfc\x8e\xd0\x82\xbb\x82\xb6\x82\xb9\x94g\x96@\x90\xab\x83\x81\x90\xa23\x88\xc0\x83\x89\x83E\x83V\x83e\x8a\xcc\x88\xf8\x83\x8c\x96\xca\x8f\x9e\x82\xe4\x82\xcb\x95\xd3\x8d\xf4\x83X\x83`\x83P\x83w\x90V\x8bI\x83\x80\x83\x8f\x83\x86\x8a\xd4\x95\xb7\x8e\xf9\x8dN\x82\xd1\x83\x89\x82\xce\x82\xbb\x81B\x8f\x82\x83g\x83e\x95\xd4\x8dZ\x82\xb0\x82\xd9\x8d\xdb\x90M\x8d\x90\x82\xc6\x82\xa6\x8eY\x93V\x83^\x83c\x83C\x83t\x94\xfc\x91\xce\x96\xca\x83E\x83`\x8bL\x95\x81\x82\xb7\x83g\x82\xcf\x8ej\x8a\xe9\x95\x91\x83g\x83\x92\x83\x91\x83P\x93n\x8c|\x83g\x83\x8f\x8a\x88\x93\xac7\x88\x9f\x8d\xcb\x96\xc5\x8di\x82\xe1\x82\xd1\x82\xa9\x82\xc1\x81B\x8f\x91\x83\x81\x8a}\x95v\x82\xe4\x95H72\x96n\x83\\\x83T\x83G\x91\xb6\x90}\x8e\xab\x82\xed\x82\xcf\x95\xb7\x8e\x8e\x83C\x82\xb9\x83h\x82\xde\x93\xc7\x96\xda\x89\xef\x83\x8c\x82\xe9\x82\xf1\x82\xad\x90E\x8a\xd4\x83L\x83\x84\x83\x91\x8f\xe3\x93\xb9\x83\x8c\x82\xd2\x96\xf13\x92\xf1\x83\x82\x95\xfb\x8f\xad\x82\xf1\x82\xb6\x83t\x92\xea\x8f\xc5\x96\xce\x94\xf7\x8e_\x82\xc3\x82\xb5\x82\xd7\x81B";

    const LOREM_IPSUM_JP_UTF8_STRING: &str = r#"続ぼひけぶ日3済なてひ流期ちな禁武ヱセヘネ首23販発ラノワ報京ぶせ計教ヲニユサ目投39作シワニ西8各如ね。質ルムフネ素熱とろや権写イルサ将図芸チスヒセ遊除なれイひ日見リヨ信期防滅票くい押関米ハ必能めレば会2各ンフか念化ぶかめん入米チラルリ飛園返樹ぼねえ。憲わフ帯瀬非どほら財案ざすき阪雄会テクマユ日計サ混子りぱ調調ぎひは人写ひぼンき角局コ指需ソチニ応子シヌヤ京件ぎじ治発ゅ阪融之押がらふ。

歩そン算井にリこ領演むみさ上映へド金9曇室る岩人フ通載ールやス美社そじせ波法性メ世3安ラウシテ肝引レ面償ゆね辺策スチケヘ新紀ムワユ間聞需康びラばそ。盾トテ返校げほ際信告とえ産天タツイフ美対面ウチ記普すトぱ史企舞トヲヱケ渡芸トワ活闘7亜才滅絞ゃびかっ。書メ笠夫ゆ菱72墨ソサエ存図辞わぱ聞試イせドむ読目会レるんく職間キヤヱ上道レぴ約3提モ方少んじフ底焦茂微酸づしべ。"#;

    const LOREM_IPSUM_NO_UTF8_STRING: &str = r#"Myndighetene har fokus på etablering av ny virksomhet: ”Norge skal være et av verdens mest nyskapende land der bedrifter og mennesker med pågangsmot og skaperevne har gode muligheter til å utvikle lønnsom virksomhet.” (Regjeringens handlingsplan for innovasjon. Det finnes flere virkemidler som alle på ulike måter kan bidra under prosessen frem til egen bedrift, og siden hjelpe deg med alle mulige spørsmål i årene etterpå. Blant disse ”hjelperne” står i første rekke Innovasjon Norge og Altinn/Starte og drive bedrift. Vi kan hjelpe deg på ulike måter. Det er viktig at du frem mot etablering ikke bare gjør tingene rik tig, men at du også gjør de riktige tingene."#;

    const LOREM_IPSUM_NO_WINDOWS_1252_BYTES: [u8; 667] = *b"Myndighetene har fokus p\xe5 etablering av ny virksomhet: \x94Norge skal v\xe6re et av verdens mest nyskapende land der bedrifter og mennesker med p\xe5gangsmot og skaperevne har gode muligheter til \xe5 utvikle l\xf8nnsom virksomhet.\x94 (Regjeringens handlingsplan for innovasjon. Det finnes flere virkemidler som alle p\xe5 ulike m\xe5ter kan bidra under prosessen frem til egen bedrift, og siden hjelpe deg med alle mulige sp\xf8rsm\xe5l i \xe5rene etterp\xe5. Blant disse \x94hjelperne\x94 st\xe5r i f\xf8rste rekke Innovasjon Norge og Altinn/Starte og drive bedrift. Vi kan hjelpe deg p\xe5 ulike m\xe5ter. Det er viktig at du frem mot etablering ikke bare gj\xf8r tingene rik tig, men at du ogs\xe5 gj\xf8r de riktige tingene.";

    #[test]
    fn test_reader_shift_jis() {
        let text = LOREM_IPSUM_JP_SHIFT_JIS_BYTES.to_vec();

        let r = BufReader::new(&text[..]);
        let mut cr = IconvReader::with_capacity(r, "SHIFT-JIS", "UTF-8", 512);

        let mut buf = [0u8; 2048];
        let len = cr.read(&mut buf).unwrap();
        assert_eq!(buf[len..len+5], [0, 0, 0, 0, 0]);

        let s = String::from_utf8(buf[..len].to_vec()).unwrap();

        assert_eq!(s, LOREM_IPSUM_JP_UTF8_STRING);
    }

    #[test]
    fn test_reader_windows_1252() {
        let text = LOREM_IPSUM_NO_WINDOWS_1252_BYTES.to_vec();

        let r = BufReader::new(&text[..]);
        let mut cr = IconvReader::with_capacity(r, "WINDOWS-1252", "UTF-8", 512);

        let mut buf = [0u8; 2048];
        // @TODO: should we expect that read will continue to read until `buf` is full?
        // currently it reads until it's internal buffer is full, and then returns
        let len = cr.read(&mut buf).unwrap();
        assert_eq!(buf[len..len+5], [0, 0, 0, 0, 0]);
        assert!(len < LOREM_IPSUM_NO_UTF8_STRING.len());
        let len = len + cr.read(&mut buf[len..]).unwrap();
        assert_eq!(len, LOREM_IPSUM_NO_UTF8_STRING.len());

        let s = String::from_utf8(buf[..len].to_vec()).unwrap();

        assert_eq!(s, LOREM_IPSUM_NO_UTF8_STRING);
    }

    #[test]
    fn test_reader_read_to_end_windows_1252() {
        let text = LOREM_IPSUM_NO_WINDOWS_1252_BYTES.to_vec();

        let r = BufReader::new(&text[..]);
        let mut cr = IconvReader::with_capacity(r, "WINDOWS-1252", "UTF-8", 256);

        let mut buf = Vec::new();
        let len = cr.read_to_end(&mut buf).unwrap();
        assert_eq!(len, LOREM_IPSUM_NO_UTF8_STRING.len());

        let s = String::from_utf8(buf).unwrap();

        assert_eq!(s, LOREM_IPSUM_NO_UTF8_STRING);
    }

    #[test]
    fn test_writer_text() {
        let mut buf = Vec::new();
        {
            let w = BufWriter::new(&mut buf);
            let mut cw = IconvWriter::with_capacity(w, "UTF-8", "SHIFT-JIS", 512);
            let data = LOREM_IPSUM_JP_UTF8_STRING.as_bytes();
            let len = cw.write(&data).unwrap();
            assert!(len < data.len());
            let len = len + cw.write(&data[len..]).unwrap();
            assert_eq!(len, data.len());
        }
        assert_eq!(buf, LOREM_IPSUM_JP_SHIFT_JIS_BYTES.to_vec());
    }

    #[test]
    fn test_writer_write_all_shift_jis() {
        let mut buf = Vec::new();
        {
            let w = BufWriter::new(&mut buf);
            let mut cw = IconvWriter::with_capacity(w, "UTF-8", "SHIFT-JIS", 512);
            let data = LOREM_IPSUM_JP_UTF8_STRING.as_bytes();
            cw.write_all(&data).unwrap();
        }
        assert_eq!(buf, LOREM_IPSUM_JP_SHIFT_JIS_BYTES.to_vec());
    }

    #[test]
    fn test_writer_write_all_windows_1252() {
        let mut buf = Vec::new();
        {
            let w = BufWriter::new(&mut buf);
            let mut cw = IconvWriter::with_capacity(w, "UTF-8", "WINDOWS-1252", 512);
            let data = LOREM_IPSUM_NO_UTF8_STRING.as_bytes();
            cw.write_all(&data).unwrap();
        }
        assert_eq!(buf, LOREM_IPSUM_NO_WINDOWS_1252_BYTES.to_vec());
    }

    #[test]
    fn test_encoder_normal() {
        assert!("".encode_with_encoding("LATIN1").unwrap().is_empty());

        let a = "哈哈";
        assert_eq!(a.encode_with_encoding("GBK").unwrap(), vec!(0xb9, 0xfe, 0xb9, 0xfe));

        let b = iter::repeat(a).take(1024).collect::<Vec<&str>>().join("");

        for ch in b.encode_with_encoding("GBK").unwrap().chunks(4) {
            assert_eq!(ch, &vec![0xb9, 0xfe, 0xb9, 0xfe][..]);
        }

        let c = vec!(0xe5, 0x93, 0x88, 0xe5, 0x93, 0x88); // utf8 bytes
        assert_eq!(c.encode_with_encoding("GBK").unwrap(), vec!(0xb9, 0xfe, 0xb9, 0xfe));
    }

    #[test]
    #[should_panic]
    fn test_encoder_fail_creating_converter() {
        assert!("".encode_with_encoding("NOT_EXISTS").unwrap().is_empty());
    }

    #[test]
    #[should_panic]
    fn test_encoder_ilseq() {
        let a = vec!(0xff, 0xff, 0xff);
        a.encode_with_encoding("GBK").unwrap();
    }

    #[test]
    #[should_panic]
    fn test_encoder_invalid() {
        let a = vec!(0xe5, 0x93, 0x88, 0xe5, 0x88); // incomplete utf8 bytes
        a.encode_with_encoding("GBK").unwrap();
    }

    #[test]
    fn test_decoder_normal() {
        let buf = Vec::new();
        let b = &buf[..];
        assert_eq!(b.decode_with_encoding("CP936").unwrap(), "".to_string());

        let a = vec!(0xb9, 0xfe, 0xb9, 0xfe);
        assert_eq!(a.decode_with_encoding("GBK").unwrap(), "哈哈".to_string());

    }

    #[test]
    #[should_panic]
    fn test_decoder_fail_creating_converter() {
        let buf = Vec::new();
        let b = &buf[..];
        assert_eq!(b.decode_with_encoding("NOT_EXSITS").unwrap(), "".to_string());
    }

    #[test]
    #[should_panic]
    fn test_decoder_ilseq() {
        let a = vec!(0xff, 0xff, 0xff);
        a.decode_with_encoding("GBK").unwrap();
    }

    #[test]
    #[should_panic]
    fn test_decoder_invalid() {
        let a = vec!(0xb9, 0xfe, 0xb9); // incomplete gbk bytes
        a.decode_with_encoding("GBK").unwrap();
    }

    #[test]
    fn test_caocao_joke() {
        let a = "曹操";
        let b = "变巨";
        assert_eq!(a.encode_with_encoding("BIG5").unwrap(),
                   b.encode_with_encoding("GBK").unwrap());
    }
}
